// Generated by CoffeeScript 1.12.6
(function() {
  var CoffeeDecorators, abstractDecorationHelper, copyMethodProps, defineDecorator, exports, getStandardDict, isClass, methodHelper, methodString, root, wrap_in_named_function,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof global === "object" && (typeof global !== "undefined" && global !== null ? global.global : void 0) === global) {
    root = global;
    exports = module.exports;
  } else {
    root = window;
    exports = window;
  }

  wrap_in_named_function = function(name, func) {
    return eval("(function " + name + "(){return func.apply(this, arguments);})");
  };

  defineDecorator = function(name, func) {
    if (root[name] != null) {
      throw new Error("Can't define decorator because `root` already has a property with name '" + name + "'.");
    }
    root[name] = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return func.apply(null, args);
    };
    return root[name];
  };

  abstractDecorationHelper = function(createErrorMessage) {
    return function() {
      var Decorated, args, cls, decoratedClass, name, namespace;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args.length === 2) {
        namespace = args[0];
        cls = args[1];
      } else if (args.length === 1) {
        namespace = this;
        cls = args[0];
      }
      if (typeof namespace !== "object" || typeof cls !== "function") {
        throw new Error("Invalid arguments. Expected (namespace, class) or (class).");
      }
      name = cls.name;
      decoratedClass = Decorated = (function(superClass) {
        var key, origClass, val;

        extend(Decorated, superClass);

        function Decorated() {
          if (this.constructor === Decorated) {
            throw new Error(createErrorMessage.call(this));
          }
          Decorated.__super__.constructor.apply(this, arguments);
        }

        origClass = Decorated;

        Decorated = wrap_in_named_function(name, Decorated);

        for (key in origClass) {
          if (!hasProp.call(origClass, key)) continue;
          val = origClass[key];
          Decorated[key] = val;
        }

        return Decorated;

      })(cls);
      if (namespace != null) {
        namespace[name] = decoratedClass;
      }
      return decoratedClass;
    };
  };

  exports.abstract = defineDecorator("abstract", abstractDecorationHelper(function() {
    return "Cannot instantiate abstract class '" + this.constructor.name + "'.";
  }));

  exports["interface"] = defineDecorator("interface", abstractDecorationHelper(function() {
    return "Cannot instantiate interface '" + this.constructor.name + "'.";
  }));

  getStandardDict = function(dict) {
    var key, method, name, result, val;
    result = {};
    for (key in dict) {
      val = dict[key];
      name = key;
      method = val;
    }
    return {
      name: name,
      method: method
    };
  };

  copyMethodProps = function(newMethod, oldMethod) {
    var key, val;
    for (key in oldMethod) {
      if (!hasProp.call(oldMethod, key)) continue;
      val = oldMethod[key];
      if (newMethod[prop] == null) {
        newMethod[key] = val;
      }
    }
    return newMethod;
  };

  methodHelper = function(callback) {
    return function(dict) {
      var cls, method, name, ref;
      ref = getStandardDict(dict), name = ref.name, method = ref.method;
      cls = this;
      method = callback(name, method, cls);
      if (typeof method === "function") {
        cls.prototype[name] = method;
      }
      return dict;
    };
  };

  isClass = function(obj) {
    return obj.prototype != null;
  };

  methodString = function(obj, methodName) {
    if (isClass(obj)) {
      return obj.name + "::" + methodName;
    }
    return obj.constructor.name + "." + methodName;
  };

  CoffeeDecorators = (function() {
    var _console;

    function CoffeeDecorators() {}

    _console = console;

    CoffeeDecorators.setConsole = function(console) {
      _console = console;
      return this;
    };

    CoffeeDecorators.getConsole = function() {
      return _console;
    };

    CoffeeDecorators.isDeprecated = function(method) {
      return method.__isDeprecated__ === true;
    };

    CoffeeDecorators.isFinal = function(method) {
      return method.__isFinal__ === true;
    };

    CoffeeDecorators.deprecated = methodHelper(function(name, method) {
      var wrapper;
      wrapper = function() {
        _console.warn("Call of " + (methodString(this, name)) + " is deprecated.");
        return method.apply(this, arguments);
      };
      wrapper.__isDeprecated__ = true;
      return copyMethodProps(wrapper, method);
    });

    CoffeeDecorators.override = methodHelper(function(name, method, cls) {
      var parent, parentMethod, ref;
      if (!cls.prototype[name]) {
        throw new Error("OVERRIDE: " + cls.name + "::" + name + " does not override '" + name + "' method. ", +"Check your class inheritance or remove the `@override` decorator!");
      }
      parent = cls;
      while ((parent = (ref = parent.__super__) != null ? ref.constructor : void 0) != null) {
        parentMethod = parent.prototype[name];
        if ((parentMethod != null) && cls.isFinal(parentMethod)) {
          throw new Error("Cannot override final method '" + parent.name + "::" + name + "' (in '" + cls.name + "')).");
        }
      }
      return method;
    });

    CoffeeDecorators["implements"] = function(interfaceCls) {
      return (function(_this) {
        return function(dict) {
          var method, name, ref;
          ref = getStandardDict(dict), name = ref.name, method = ref.method;
          _this.prototype[name] = method;
          if (indexOf.call(heterarchy.mro(_this), interfaceCls) < 0 || !(interfaceCls.prototype[name] instanceof Function)) {
            throw new Error("IMPLEMENTS: " + _this.name + "::" + name + " does not implement the '" + interfaceCls.name + "' interface.");
          }
          return dict;
        };
      })(this);
    };

    CoffeeDecorators.abstract = function(dict) {
      var cls, method, name, ref, wrapperMethod;
      ref = getStandardDict(dict), name = ref.name, method = ref.method;
      cls = this;
      wrapperMethod = function() {
        if (this[name] === cls.prototype[name]) {
          throw new Error((cls.getName()) + "::" + name + " must not be called because it is abstract and must be overridden.");
        }
      };
      this.prototype[name] = copyMethodProps(wrapperMethod, method);
      return dict;
    };

    CoffeeDecorators.cachedProperty = function(dict) {
      var cache, method, name, nullRef, ref;
      ref = getStandardDict(dict), name = ref.name, method = ref.method;
      nullRef = {};
      cache = nullRef;
      Object.defineProperty(this.prototype, name, {
        get: function() {
          if (cache === nullRef) {
            cache = method.call(this);
          }
          return cache;
        },
        set: function(value) {
          cache = value;
          return cache;
        }
      });
      return dict;
    };

    CoffeeDecorators.cached = function(dict) {
      var argListsEqual, cache, createCache, method, name, nullRef, ref, wrapperMethod;
      throw new Error("Don't use @cached yet!");
      ref = getStandardDict(dict), name = ref.name, method = ref.method;
      nullRef = {};
      argListsEqual = function(args1, args2) {
        var args1Elem, args2Elem, i, j, len;
        if (args1.length !== args2.length) {
          return false;
        }
        for (i = j = 0, len = args1.length; j < len; i = ++j) {
          args1Elem = args1[i];
          args2Elem = args2[i];
          if ((typeof args1Elem.equals === "function" ? args1Elem.equals(args2Elem) : void 0) === false || (typeof args2Elem.equals === "function" ? args2Elem.equals(args1Elem) : void 0) === false || args1Elem !== args2Elem) {
            return false;
          }
        }
        return true;
      };
      createCache = function() {
        return new App.Hash(null, nullRef, argListsEqual);
      };
      cache = createCache();
      wrapperMethod = function() {
        var args, value;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        value = cache.get(args);
        if (value === nullRef) {
          value = method.apply(this, args);
          cache.put(args, value);
        }
        return value;
      };
      wrapperMethod.clearCache = function() {
        return cache = createCache();
      };
      this.prototype[name] = copyMethodProps(wrapperMethod, method);
      return dict;
    };

    CoffeeDecorators.final = function(dict) {
      var cls, method, name, ref, wrapperMethod;
      ref = getStandardDict(dict), name = ref.name, method = ref.method;
      cls = this;
      wrapperMethod = function() {
        if (this[name] !== cls.prototype[name]) {
          throw new Error("Method '" + (cls.prototype.getClassName()) + "::" + name + "' is final and must not be overridden (in '" + (this.getClassName()) + "')");
        }
        return method.apply(this, arguments);
      };
      wrapperMethod.isFinal = true;
      this.prototype[name] = copyMethodProps(wrapperMethod, method);
      return dict;
    };

    return CoffeeDecorators;

  })();

  exports.CoffeeDecorators = CoffeeDecorators;

}).call(this);
