// Generated by CoffeeScript 1.12.6
(function() {
  var abstractDecorationHelper, copyMethodProps, defineDecorator, exports, getStandardDict, nameOfClass, root, wrap_in_named_function,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof global === "object" && (typeof global !== "undefined" && global !== null ? global.global : void 0) === global) {
    root = global;
    exports = module.exports;
  } else {
    root = window;
  }

  wrap_in_named_function = function(name, func) {
    return eval("(function " + name + "(){return func.apply(this, arguments);})");
  };

  defineDecorator = function(name, func) {
    if (root[name] != null) {
      throw new Error("Can't define decorator because `root` already has a property with name '" + name + "'.");
    }
    root[name] = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return func.apply(null, args);
    };
    return root[name];
  };

  abstractDecorationHelper = function(createErrorMessage) {
    return function() {
      var Decorated, args, cls, decoratedClass, name, namespace;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      debugger;
      if (args.length === 2) {
        namespace = args[0];
        cls = args[1];
      } else if (args.length === 1) {
        namespace = this;
        cls = args[0];
      } else {
        throw new Error("Invalid arguments. Expected (namespace, class) or (class).");
      }
      name = cls.name;

      /*
      name = "asdf"
      asdf = class Wrapper
        constructor: () ->
          @a = "__prop__"
        Wrapper = wrap_in_named_function(name, Wrapper)
      
        m: -> 2
      
      o = new asdf()
      alert o.m() + o.a + asdf.name # -> 2__prop__asdf
       */
      decoratedClass = Decorated = (function(superClass) {
        var key, origClass, val;

        extend(Decorated, superClass);

        function Decorated() {
          if (this.constructor === Decorated) {
            throw new Error(createErrorMessage.call(this));
          }
          Decorated.__super__.constructor.apply(this, arguments);
        }

        origClass = Decorated;

        Decorated = wrap_in_named_function(name, Decorated);

        for (key in origClass) {
          if (!hasProp.call(origClass, key)) continue;
          val = origClass[key];
          Decorated[key] = val;
        }

        return Decorated;

      })(cls);
      if (namespace != null) {
        namespace[name] = decoratedClass;
      }
      return decoratedClass;
    };
  };

  defineDecorator("abstract", abstractDecorationHelper(function() {
    return "Cannot instantiate abstract class '" + this.constructor.name + "'.";
  }));

  defineDecorator("interface", abstractDecorationHelper(function() {
    return "Cannot instantiate interface '" + this.constructor.name + "'.";
  }));

  return;

  getStandardDict = function(dict) {
    var key, method, name, result, val;
    result = {};
    for (key in dict) {
      val = dict[key];
      name = key;
      method = val;
    }
    return {
      name: name,
      method: method
    };
  };

  copyMethodProps = function(newMethod, oldMethod) {
    var j, len, prop, props;
    props = ["clearCache", "isFinal"];
    for (j = 0, len = props.length; j < len; j++) {
      prop = props[j];
      if ((oldMethod[prop] != null) && (newMethod[prop] == null)) {
        newMethod[prop] = oldMethod[prop];
      }
    }
    return newMethod;
  };

  nameOfClass = function(cls) {
    return (typeof cls.getName === "function" ? cls.getName() : void 0) || cls.name || "";
  };

  Object.deprecated = function(dict) {
    var method, name, ref, wrapperMethod;
    ref = this._getStandardDict(dict), name = ref.name, method = ref.method;
    wrapperMethod = function() {
      console.warn("Deprecated call of " + (this.getClassName()) + "::" + name + ".");
      return method.apply(this, arguments);
    };
    this.prototype[name] = this._copyMethodProps(wrapperMethod, method);
    return dict;
  };

  Object.override = function(dict) {
    var method, name, parent, parentMethod, ref, ref1, ref2;
    ref = this._getStandardDict(dict), name = ref.name, method = ref.method;
    if (!this.prototype[name]) {
      throw new Error("OVERRIDE: " + (nameOfClass(this)) + "::" + name + " does not override '" + name + "' method. Check your class inheritance or remove the `@override` decorator!");
    }
    parent = (ref1 = this.__super__) != null ? ref1.constructor : void 0;
    while (parent != null) {
      parentMethod = parent.prototype[name];
      if ((parentMethod != null) && parentMethod.isFinal === true) {
        throw new Error("Cannot override final method '" + (nameOfClass(parent)) + "::" + name + "' (in '" + (nameOfClass(this)) + "')).");
      }
      parent = (ref2 = parent.__super__) != null ? ref2.constructor : void 0;
    }
    this.prototype[name] = method;
    return dict;
  };

  Object["implements"] = function(interfaceCls) {
    return (function(_this) {
      return function(dict) {
        var method, name, ref;
        ref = _this._getStandardDict(dict), name = ref.name, method = ref.method;
        _this.prototype[name] = method;
        if (indexOf.call(heterarchy.mro(_this), interfaceCls) < 0 || !(interfaceCls.prototype[name] instanceof Function)) {
          throw new Error("IMPLEMENTS: " + _this.name + "::" + name + " does not implement the '" + interfaceCls.name + "' interface.");
        }
        return dict;
      };
    })(this);
  };

  Object.abstract = function(dict) {
    var cls, method, name, ref, wrapperMethod;
    ref = this._getStandardDict(dict), name = ref.name, method = ref.method;
    cls = this;
    wrapperMethod = function() {
      if (this[name] === cls.prototype[name]) {
        throw new Error((cls.getName()) + "::" + name + " must not be called because it is abstract and must be overridden.");
      }
    };
    this.prototype[name] = this._copyMethodProps(wrapperMethod, method);
    return dict;
  };

  Object.cachedProperty = function(dict) {
    var cache, method, name, nullRef, ref;
    ref = this._getStandardDict(dict), name = ref.name, method = ref.method;
    nullRef = {};
    cache = nullRef;
    Object.defineProperty(this.prototype, name, {
      get: function() {
        if (cache === nullRef) {
          cache = method.call(this);
        }
        return cache;
      },
      set: function(value) {
        cache = value;
        return cache;
      }
    });
    return dict;
  };

  Object.cached = function(dict) {
    var argListsEqual, cache, createCache, method, name, nullRef, ref, wrapperMethod;
    throw new Error("Don't use @cached yet!");
    ref = this._getStandardDict(dict), name = ref.name, method = ref.method;
    nullRef = {};
    argListsEqual = function(args1, args2) {
      var args1Elem, args2Elem, i, j, len;
      if (args1.length !== args2.length) {
        return false;
      }
      for (i = j = 0, len = args1.length; j < len; i = ++j) {
        args1Elem = args1[i];
        args2Elem = args2[i];
        if ((typeof args1Elem.equals === "function" ? args1Elem.equals(args2Elem) : void 0) === false || (typeof args2Elem.equals === "function" ? args2Elem.equals(args1Elem) : void 0) === false || args1Elem !== args2Elem) {
          return false;
        }
      }
      return true;
    };
    createCache = function() {
      return new App.Hash(null, nullRef, argListsEqual);
    };
    cache = createCache();
    wrapperMethod = function() {
      var args, value;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      value = cache.get(args);
      if (value === nullRef) {
        value = method.apply(this, args);
        cache.put(args, value);
      }
      return value;
    };
    wrapperMethod.clearCache = function() {
      return cache = createCache();
    };
    this.prototype[name] = this._copyMethodProps(wrapperMethod, method);
    return dict;
  };

  Object.final = function(dict) {
    var cls, method, name, ref, wrapperMethod;
    ref = this._getStandardDict(dict), name = ref.name, method = ref.method;
    cls = this;
    wrapperMethod = function() {
      if (this[name] !== cls.prototype[name]) {
        throw new Error("Method '" + (cls.prototype.getClassName()) + "::" + name + "' is final and must not be overridden (in '" + (this.getClassName()) + "')");
      }
      return method.apply(this, arguments);
    };
    wrapperMethod.isFinal = true;
    this.prototype[name] = this._copyMethodProps(wrapperMethod, method);
    return dict;
  };

}).call(this);
