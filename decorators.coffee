# node.js
if typeof global is "object" and global?.global is global
    root = global
    exports = module.exports
# browser
else
    root = window


wrap_in_named_function = (name, func) ->
    return eval("(function " + name + "(){return func.apply(this, arguments);})")




defineDecorator = (name, func) ->
    if root[name]?
        throw new Error("Can't define decorator because `root` already has a property with name '#{name}'.")
    root[name] = (args...) ->
        return func(args...)
    return root[name]


# HELPERS
abstractDecorationHelper = (createErrorMessage) ->
    return (args...) ->
        debugger
        if args.length is 2
            namespace = args[0]
            cls = args[1]
        else if args.length is 1
            namespace = @
            cls = args[0]
        else
            throw new Error("Invalid arguments. Expected (namespace, class) or (class).")

        name = cls.name

        ###
        name = "asdf"
        asdf = class Wrapper
          constructor: () ->
            @a = "__prop__"
          Wrapper = wrap_in_named_function(name, Wrapper)

          m: -> 2

        o = new asdf()
        alert o.m() + o.a + asdf.name # -> 2__prop__asdf
        ###

        # cls is also the old constructor
        decoratedClass = class Decorated extends cls
            constructor: () ->
                if @constructor is Decorated
                    throw new Error(createErrorMessage.call(@))
                # call actual constructor
                # NOTE: no paranthesis => `.apply(this, arguments)`
                super
                # Decorated.__super__.constructor.apply(this, arguments)
                # decoratedClass.__super__.constructor.apply(@, arguments)

            # Wrapping the function results in the loss of properties -> we use this reference to reattach them
            origClass = Decorated
            # wrap the constructor and give it the `name`
            Decorated = wrap_in_named_function(name, Decorated)
            # reattach __super__ and all other class attributes
            for own key, val of origClass
                Decorated[key] = val

        # # This fix is necessary because after the decoration of the class App[name] points to a new constructor. Therefore (in main.coffee) attaching `getName` and `getClassName` will be done on the decorated class only.
        # # When using `heterarchy.mro` the undecorated classes are returned (e.g. in `AxisWidget::_changeIsRegarded`).
        # # Those should also return the correct class names.
        # if not cls.getName?
        #     cls.getName = () ->
        #         return name
        #     cls::getName = () ->
        #         return name

        if namespace?
            namespace[name] = decoratedClass
        return decoratedClass


# DECORATORS

# These decorators only work for classes that are (directly) defined in the `App` namespace.
defineDecorator "abstract", abstractDecorationHelper () ->
    return "Cannot instantiate abstract class '#{@constructor.name}'."

defineDecorator "interface", abstractDecorationHelper () ->
    return "Cannot instantiate interface '#{@constructor.name}'."



return







# helper function that converts given 1-elemtent dict (with any key) to {name, method}.
# the given dict is generated by using decorators/annotations like so:
#
# CoffeeScript:
#   @deprecated \
#   method: () ->
#
# JavaScript:
#   <CLASS_NAME>.deprecated({
#       method: function() {}
#   })
getStandardDict = (dict) ->
    result = {}
    for key, val of dict
        name = key
        method = val
    return {name, method}

# helper function to copy all properties in case of decorator chaining
copyMethodProps = (newMethod, oldMethod) ->
    props = [
        "clearCache"
        "isFinal"
    ]
    for prop in props when oldMethod[prop]? and not newMethod[prop]?
        newMethod[prop] = oldMethod[prop]
    return newMethod

nameOfClass = (cls) ->
    return cls.getName?() or cls.name or ""

# DECORATORS FOR INSIDE CLASSES THAT EXTEND THE NATIVE OBJECT
# ALL ANNOTATIONS MUST RETURN THE GIVEN `dict` FOR ANNOTATION CHAINING
Object.deprecated = (dict) ->
    {name, method} = @_getStandardDict(dict)
    wrapperMethod = () ->
        console.warn "Deprecated call of #{@getClassName()}::#{name}."
        return method.apply(@, arguments)
    @::[name] = @_copyMethodProps(wrapperMethod, method)
    return dict

Object.override = (dict) ->
    {name, method} = @_getStandardDict(dict)
    # the prototype does not already contain the method
    # => it was not defined in a superclass
    # => method is NOT overridden
    if not @::[name]
        throw new Error("OVERRIDE: #{nameOfClass(@)}::#{name} does not override '#{name}' method. Check your class inheritance or remove the `@override` decorator!")
    # look for final super methods
    parent = @__super__?.constructor
    while parent?
        parentMethod = parent::[name]
        if parentMethod? and parentMethod.isFinal is true
            throw new Error("Cannot override final method '#{nameOfClass(parent)}::#{name}' (in '#{nameOfClass(@)}')).")
        parent = parent.__super__?.constructor
    @::[name] = method
    return dict

# this method is different than most because it is used like:
# @implements(App.ExampleInterface) \
# method: (a, b) ->
# Thus it gets the interface as argument and must return a function that gets the `dict`.
Object.implements = (interfaceCls) ->
    # this function gets called immediately
    return (dict) =>
        {name, method} = @_getStandardDict(dict)
        @::[name] = method
        if interfaceCls not in heterarchy.mro(@) or interfaceCls::[name] not instanceof Function
            throw new Error("IMPLEMENTS: #{@name}::#{name} does not implement the '#{interfaceCls.name}' interface.")
        return dict

Object.abstract = (dict) ->
    {name, method} = @_getStandardDict(dict)
    cls = @
    wrapperMethod = () ->
        # this check must contain dynamic lookup because the method could still be replaced by further decorators (-> wrappers)
        if @[name] is cls::[name]
            throw new Error("#{cls.getName()}::#{name} must not be called because it is abstract and must be overridden.")
    @::[name] = @_copyMethodProps(wrapperMethod, method)
    return dict

Object.cachedProperty = (dict) ->
    {name, method} = @_getStandardDict(dict)
    nullRef = {}
    cache = nullRef
    Object.defineProperty @::, name, {
        get: () ->
            if cache is nullRef
                cache = method.call(@)
            return cache
        set: (value) ->
            cache = value
            return cache
    }
    return dict

# Incrementally fills a dictionary of arguments-result pairs.
# Arguments are compared using the argument's `equals` interface or with `===`.
# The decorated method has a `clearCache()` method to reset the cache.
Object.cached = (dict) ->
    # TODO: fix this: the cache is used across all different instances of a class (which results in really wrong behavior)
    throw new Error("Don't use @cached yet!")
    {name, method} = @_getStandardDict(dict)
    nullRef = {}
    # maps arguments to return value
    argListsEqual = (args1, args2) ->
        if args1.length isnt args2.length
            return false
        for args1Elem, i in args1
            args2Elem = args2[i]
            if args1Elem.equals?(args2Elem) is false or
                args2Elem.equals?(args1Elem) is false or
                args1Elem isnt args2Elem
                    return false
        return true
    createCache = () ->
        return new App.Hash(null, nullRef, argListsEqual)
    cache = createCache()
    wrapperMethod = (args...) ->
        value = cache.get(args)
        if value is nullRef
            value = method.apply(@, args)
            cache.put(args, value)
        return value
    wrapperMethod.clearCache = () ->
        cache = createCache()
    @::[name] = @_copyMethodProps(wrapperMethod, method)
    return dict

# only works if an accidental overriding method uses `@override` or calls `super`
Object.final = (dict) ->
    {name, method} = @_getStandardDict(dict)
    cls = @
    wrapperMethod = () ->
        if @[name] isnt cls::[name]
            # `cls::getClassName()` is used insteaf of `cls.getName()` because heterarchy does not correctly support class method inheritance
            throw new Error("Method '#{cls::getClassName()}::#{name}' is final and must not be overridden (in '#{@getClassName()}')")
        return method.apply(@, arguments)
    wrapperMethod.isFinal = true
    @::[name] = @_copyMethodProps(wrapperMethod, method)
    return dict
